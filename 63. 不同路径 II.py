"""
63. 不同路径 II
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
"""
from typing import List
"""
#本方法为回溯，但是会超时
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
      m = len(obstacleGrid)
      n = len(obstacleGrid[0])
      out = []
      
      def backtrack(count, row, col):
        if obstacleGrid[row][col] == 1:#遇到障碍，返回
          return 
        if count == (m+n-2):#总共计算移动的总数
          out.append(1)#
          return
        if col == n - 1 and row < m - 1:#到达网格的最右端，只能往下走
          backtrack(count + 1, row + 1, col)
        elif row == m - 1 and col < n - 1:#达到网格的最下端，只能往右走
          backtrack(count + 1, row, col + 1)
        else:#在网格内部，往下走，往右走都可以
          backtrack(count + 1, row + 1, col)
          backtrack(count + 1, row, col + 1)
      
      backtrack(0,0,0)
      return len(out)
"""
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
      m = len(obstacleGrid)
      n = len(obstacleGrid[0])
      out = [[1] * n for i in range(m)]#先建立一个全为1的网格
      for i in range(n):#对第一行有障碍的格子之后全部置0
        if obstacleGrid[0][i] == 1:
          while i < n:
            out[0][i] = 0
            i += 1
          break

      for i in range(m):#对第一列有障碍的格子之后全部置0
        if obstacleGrid[i][0] == 1:
          while i < m:
            out[i][0] = 0
            i += 1
          break

      for i in range(1, m):#对内部的格子进行判断，每个格子的值为达到该格子的步数
        for j in range(1, n):
          if obstacleGrid[i][j] == 1:#如果当前格子有障碍，则不能达到该格子，置0
            out[i][j] = 0
          else:#如果可以到达该格子，则该格子的值等于左边的格子加上面的格子内的值
            out[i][j] = out[i][j-1] + out[i-1][j]
      return out[m-1][n-1]
      
if __name__ == "__main__":
  s = Solution()
  print(s.uniquePathsWithObstacles([
[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],
[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],
[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],
[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],
[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],
[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],
[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],
[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],
[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],
[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],
[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],
[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],
[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],
[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],
[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],
[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],
[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]
  ))




    

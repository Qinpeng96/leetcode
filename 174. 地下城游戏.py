"""
174. 地下城游戏
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。
我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；
其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)
 

说明:

骑士的健康点数没有上限。

任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

"""
"""
首先看到这道题，就想到使用动态规划，但是试着做了一下，正向的动态规划好像不行，再仔细读题，发现这道题应该是倒着推导，所以应该使用倒叙的dp。

根据题意，将要走到最后一个格子里面的时候，应该剩余的生命值应该为正数，取值为[ 1, -dungeon[-1][-1]+1 ]，所以例如最后一个格子内的数位-5，
那么我们在走到这个格子前的生命值至少为 -(-5)+1等于6；加入格子内的生命值为 5，那么我们走到这个格子前的生命值最少为 1就可以了，
所以在dp中最后一个格子取值为 max( 1, -dungeon[ i ][ j ]+1 )。

由于是倒推，接下来我们来看最后一行：最后一行的值只与其右边的数值有管，类似上面的方法，最后一行的格子值最小也是取1，这样才能在中途存活，
其最大值应该使得和下一个dungon内的值相加之后等于下一个dp所需要的值。其公式为

解释一下上面的公式：假如在dp[ i ][ j+1]处为 5，表示，走到（i， j+1）处的时候生命值至少为5，由于是最后一行，
所以通往（i，j+1）只有从（i，j）过去。dp[ i ][ j ] + dungon[ i ][ j ]的值就是dp[ i ][ j+1 ]的值，但是这个值可能为一个负数，
不一定为整数，假如 dungon[ i ][ j ]为一个比较大的负数，这样dp[ i ][ j+1 ]，也为负数，说明骑士已经死亡，所以这里的生命值至少为1。
如果相加后为复数就取1，max操作。

同理最后一列也是这样取值的。

中间的值也是类似，首先去一个max(1, ?)，保证之后的生命值为正数。由于我们是倒过来求，所以就当前取值与下面和右边的取值有管，
由于我们是要找最小生命值，所以对下面和右边的生命值取一个min。


"""
from typing import List
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        col = len(dungeon[0])
        row = len(dungeon)
        res = 0
        dp = [[0]*(col) for _ in range(row)]
        for i in range(row-1,-1,-1):
            for j in range(col-1,-1,-1):
                if i == row-1 and j == col-1:#最后一个
                    dp[i][j] = max(1, -dungeon[i][j]+1)
                elif i == row-1 and j < col-1:#最后一行
                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j])
                elif j == col-1 and i < row-1:#最后一列
                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j])
                else:#其余的数
                    dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j]) - dungeon[i][j])
                res = min(res, dp[i][j])

        return dp[0][0]


if __name__ == "__main__":
    s = Solution()
    print(s.calculateMinimumHP([
        [-2,-3,3],
        [-5,-10,1],
        [10,30,-5]
    ]))
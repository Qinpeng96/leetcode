"""
[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
***
首先对身高升序排序，同时又对个数k降序排序。每次首个列表组中的身高是最低的，他所在的k值就是原始排序数组内应该存在的位置。注意，这里我们排好一个数之后，要在数组索引中删去当前值对应的索引。

原理：
按照身高由低到高进行排序，因为身高低，那么在它前面的人的个数是可以确定的，就是其当前的K值索引对应的位置。随着K索引在数组中被删除，为什么要删除了？假如有一个数在【4，4】后面，那么由于其身高肯定是比4高的，那么在计算索引的时候，就不会把4计算进去，**相当于在原数组内已经排好了[4,4]的位置了，要把它从里面删除**。
"""
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        """
        [ 0, 1, 2, 3, 4, 5 ] [ 4, 4 ] 4
        [ 0, 1, 2, 3, 5 ]    [ 5, 2 ] 2
        [ 0, 1, 3, 5 ]       [ 5, 0 ] 0
        [ 1, 3, 5 ]          [ 6, 1 ] 3
        [ 1, 5 ]             [ 7, 1 ] 5
        [ 1 ]                [ 7, 0 ] 1
        [ [ 5, 0 ], [ 7, 0 ], [ 5, 2 ], [ 6, 1 ], [ 4, 4 ], [ 7, 1 ] ]
        身高升序，个数降序排列,每次插入k索引对应值的剩余的位置
        """
        people.sort(key = lambda x:(x[0],-x[1]))
        n = len(people)
        out = [[-1, -1] for _ in range(n)]
        num = [i for i in range(n)]
    
        for x,y in people:
            out[num[y]] = [x,y]
            num.pop(y)
        return out
```
"""
还有一种方法就是身高从高到低排序，K值个数从低到高排序。
这种方法比较自然，每次排身高最高，前面人数最少的，之后的就是插入到其后面。
"""
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        """
       	[ 4, 4 ] 	  	[7, 0] 0
        [ 5, 2 ] 		[7, 1] 1
        [ 5, 0 ] 		[6, 1] 1
        [ 6, 1 ] 		[5, 0] 0
        [ 7, 1 ] 		[5, 1] 1
        [ 7, 0 ] 		[4, 4] 4
        [ [ 5, 0 ], [ 7, 0 ], [ 5, 2 ], [ 6, 1 ], [ 4, 4 ], [ 7, 1 ] ]
        身高升序，个数降序排列,每次插入k索引对应值的剩余的位置
        """
        people.sort(key = lambda x: (-x[0], x[1]))
        out = []
        for h, k in people:
            out.insert(k, [h,k])
        return out
```

